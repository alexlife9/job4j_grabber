package ru.job4j.gc;

/**
 * Понятие сборки мусора
 *
 * Что такое "мусор"? Мусором считается объект, который больше не может быть достигнут по ссылке
 * из какого-либо объекта. Поскольку такие объекты больше не используются в приложении, то их можно удалить из памяти.
 *
 *
 * Что такое сборка мусора? Сборка мусора — это процесс автоматического управления памятью.
 * Освобождение памяти (путем очистки мусора) выполняется автоматически специальным
 * компонентом JVM — сборщиком мусора (Garbage Collector, GC).
 *
 *
 * Для сборки мусора используется алгоритм пометок (Mark & Sweep). Этот алгоритм состоит из трех этапов:
 * 1. Mark (маркировка). На первом этапе GC сканирует все объекты и помечает живые (объекты,
 * которые все еще используются). На этом шаге выполнение программы приостанавливается.
 * Поэтому этот шаг также называется "Stop the World" .
 * 2. Sweep (очистка). На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.
 * 3. Compact (уплотнение). Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти.
 * Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.
 *
 *
 * Что такое поколения объектов?
 * Для оптимизации сборки мусора память кучи дополнительно разделена на четыре области.
 * В эти области объекты помещаются в зависимости от их возраста (как долго они используются в приложении).
 * 1. Young Generation (молодое поколение). Здесь создаются новые объекты.
 * Область young generation разделена на 3 раздела: Eden (Эдем), S0 и S1 (Survivor Space — область для выживших).
 * 2. Old Generation (старое поколение). Здесь хранятся давно живущие объекты.
 *
 *
 * Как уже упоминалось ранее, для оптимизации этапов mark и sweep используются поколения.
 * Гипотеза о поколениях говорит о следующем:
 * 1. Большинство объектов живут недолго.
 * 2. Если объект выживает, то он, скорее всего, будет жить вечно.
 * 3. Этапы mark и sweep занимают меньше времени при большом количестве мусора.
 * То есть маркировка будет происходить быстрее, если анализируемая область небольшая и в ней много мертвых объектов.
 *
 * Таким образом, алгоритм сборки мусора, использующий поколения, выглядит следующим образом:
 * 1. Новые объекты создаются в области Eden. Области Survivor (S0, S1) на данный момент пустые.
 * 2. Когда область Eden заполняется, происходит минорная сборка мусора (Minor GC).
 * Minor GC — это процесс, при котором операции mark и sweep выполняются для young generation (молодого поколения).
 * 3. После Minor GC живые объекты перемещаются в одну из областей Survivor (например, S0).
 * Мертвые объекты полностью удаляются.
 * 4. По мере работы приложения пространство Eden заполняется новыми объектами.
 * При очередном Minor GC области young generation и S0 очищаются. На этот раз выжившие объекты
 * перемещаются в область S1, и их возраст увеличивается (отметка о том, что они пережили сборку мусора).
 * 5. При следующем Minor GC процесс повторяется. Однако на этот раз области Survivor меняются местами.
 * Живые объекты перемещаются в S0 и у них увеличивается возраст. Области Eden и S1 очищаются.
 * 6. Объекты между областями Survivor копируются определенное количество раз (пока не переживут
 * определенное количество Minor GC) или пока там достаточно места. Затем эти объекты копируются в область Old.
 * 7. Major GC. При Major GC этапы mark и sweep выполняются для Old Generation.
 * Major GC работает медленнее по сравнению с Minor GC, поскольку старое поколение в основном состоит из живых объектов.
 *
 * @author Alex_life
 * @version 1.0
 * @since 02.09.2022
 */
public class GCDemo {

    private static final long KB = 1000;
    private static final long MB = KB * KB;
    private static final Runtime ENVIRONMENT = Runtime.getRuntime();

    /**
     * - freeMemory(), возвращает количество свободной памяти в байтах
     * - totalMemory(), возвращает общее количество памяти которое может быть использовано
     * - maxMemory(), возвращает максимальное количество памяти которое может быть использовано
     * Мы создаем в цикле 10000 объектов. Если запустить этот код, то можно увидеть, что происходит очистка мусора:
     */
    public static void info() {
        final long freeMemory = ENVIRONMENT.freeMemory();
        final long totalMemory = ENVIRONMENT.totalMemory();
        final long maxMemory = ENVIRONMENT.maxMemory();
        System.out.println("=== Environment state ===");
        System.out.printf("Free: %d%n", freeMemory / MB);
        System.out.printf("Total: %d%n", totalMemory / MB);
        System.out.printf("Max: %d%n", maxMemory / MB);
    }

    public static void main(String[] args) {
        info();
        for (int i = 0; i < 10; i++) {
            new Person(i, "N" + i);
        }
        System.gc();
        info();
    }

}
