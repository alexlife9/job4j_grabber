package ru.job4j.ood.ocp;

import java.util.function.BiFunction;

/**
 * Принципы ООД (объектно-ориентированного дизайна)
 * Принцип открытости закрытости - Open Closed Principle
 *
 * Все шаблоны проектирования были придуманы как раз таким образом, чтобы код не только решал некоторую задачу дизайна,
 * но и соответствовал принципам SOLID. Таким образом,понимание этих принципов делает очевидными шаблоны проектирования.
 *
 * SOLID – это аббревиатура, составленная из первых букв названий принципов:
 * S – Single Responsibility Principle
 * O – Open-Closed Principle
 * L – Liskov Substitution Principle
 * I – Interface Segregation Principle
 * D – Dependency Inversion Principle
 *
 * Принцип OCP гласит, что программные сущности должны быть открыты к расширению, но закрыты к изменению.
 *
 * Допустим нужно будет добавить операцию вычитания в программу.
 * Для класса SimpleCalculator нужно будет добавить еще метод, т.е. его изменить.
 * Для класса AbstractCalculator достаточно будет передать новую лямбду, т.е. расширить программу, не изменяя ее.
 *
 * Почему так важен факт закрытия изменений?
 * 1) Изменение программы может привести к ее некорректной работе. Если программа маленькая,
 * то продебажить ее не трудно, но если в ней много кода, то это будет сделать затруднительно,
 * поэтому становится актуальным ее расширение, а не изменение.
 * 2) Программы со временем меняются. Меняются требования. Выходят новые версии.
 * Все это делается за счет возможности гибкого расширения программы.
 *
 * Контекст расширения.
 * Говоря о расширении важно отметить контекст, в котором мы говорим о нем. В примере CalculatorExample мы говорим
 * об отдельно взятом внутреннем классе, а именно о внутреннем устройстве этих классов.
 *
 * К примеру, кто-то может сказать: первый класс мы можем тоже расширить, например через наследование.
 * Но тут уже другой контекст – контекст, в котором будет применяться сам класс. А это уже совсем другое.
 *
 * Таким образом при написании расширяемых классов стоит обращать внимание:
 * 1) на создаваемые объекты. Помните классы должны зависеть от абстракций, а не от реализаций (принцип DIP).
 * 2) на поля. Поля также должны представлять тип абстракций. Такой вариант тоже может привести к сложностям расширения,
 * так как, чтобы расширить программу придется наследоваться, но не всегда наследование возможно.
 * 3) на параметры и возвращаемые типы методов. Они тоже должны быть абстракциями.
 *
 * Если говорить кратко, взаимодействие должно быть строго через абстракции (интерфейсы, абстрактные классы),
 * за исключением примитивных типов и не изменяемых типов (строки, классы-обертки, в общем классы помеченные final),
 * которые в конечном счете представляют собой состояние объектов.
 *
 * Механизмы расширения. Расширение, как правило, достигается созданием новых сущностей.
 * Тут мы ярко можем увидеть полиморфизм. Таким образом, расширение достигается за счет полиморфизма.
 * Полиморфизм достигается за счет: 1.Наследование, 2.Интерфейсы и их реализация
 *
 * Наследование можно использовать только при устойчивой иерархии классов, всегда подставляйте «is A» между сущностями,
 * чтобы проверить можно ли наследоваться. Если не уверены, то лучше использовать интерфейсы,
 * потому что они дают гибкость. Также помните, что при наследовании наследуется состояние объектов,
 * что не всегда удобно, нужно и допустимо.
 *
 * @author Alex_life
 * @version 1.0
 * @since 25.09.2022
 */
public class CalculatorExample {

    private static class SimpleCalculator {
        public int sum(int a, int b) {
            return a + b;
        }
    }

    private static class AbstractCalculator<T> {
        public T calculate(BiFunction<T, T, T> function, T first, T second) {
            return function.apply(first, second);
        }
    }
}
