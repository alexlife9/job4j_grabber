package ru.job4j.ood.lsp;

/**
 * Принципы ООД (объектно-ориентированного дизайна)
 * Принцип подстановки Лисков - Liskov Substitution Principle
 *
 * Все шаблоны проектирования были придуманы как раз таким образом, чтобы код не только решал некоторую задачу дизайна,
 * но и соответствовал принципам SOLID. Таким образом,понимание этих принципов делает очевидными шаблоны проектирования.
 *
 * SOLID – это аббревиатура, составленная из первых букв названий принципов:
 * S – Single Responsibility Principle
 * O – Open-Closed Principle
 * L – Liskov Substitution Principle
 * I – Interface Segregation Principle
 * D – Dependency Inversion Principle
 *
 * Принцип подстановки Лисков гласит, что если в коде используется сущность X, то при постановке его наследников
 * или других реализаций Y код будет работать. Фактически этот принцип гарантирует,
 * что не нарушится принцип OCP относительно взаимосвязи между классами в иерархии.
 *
 * В общем случае данный принцип можно сформулировать так:
 * Должна быть возможность вместо базового типа подставить любой его подтип.
 *
 * В своей статье Барбара Лисков определила свой принцип следующим образом: “Объекты в программе
 * должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы”.
 *
 * Чтобы проверить не нарушает ли код этот принцип, нужно представить что нужно будет использовать в коде какие-то
 * специфические реализации и попытаться мысленно их подставить. Если нет проблем с подстановкой, то все отлично.
 * В целом не должно быть завязки на конкретной реализации.
 *
 * Контракты LSP
 * Контракт - это некое правило, соблюдение которого гарантирует, что принцип не будет нарушен.
 * Применительно LSP выделяют следующие контракты:
 *
 * 1. Предусловия (Preconditions) не могут быть усилены в подклассе. Это такие условия,
 * которые проверяют корректность аргументов конструктора или метода.
 *
 * 2. Постусловия (Postconditions) не могут быть ослаблены в подклассе.
 * Это условия, налагаемые на возвращаемое значение метода.
 * Правила 1-2 не распространяются на приватные поля, т.е. когда вы проверяете специфичные только для объекта поля,
 * то вы не нарушаете эти правила. Принцип Лисков контролирует отношения между классами при наследовании.
 *
 * 3. Инварианты (Invariants) — все условия базового класса также должны быть сохранены и в подклассе.
 * Инвариант - это условие, которое постоянно на протяжении существования объекта.
 *
 *
 * Признаки нарушения принципа LSP:
 * 1. Использование методов getClass(), instance of
 * 2. Написание кода с наличием слова type. Часто код, где есть методы setType(), getType() нарушает принцип LSP.
 * Исключением здесь является использование рефлексии, которая сама собой предполагает извлечение и модификацию
 * метаинформации о классах. Обычно совместно с этим идет использование enum.
 * Это не означает, что нужно избегать использования enum, это означает, что нужно тщательно подумать прежде чем
 * ограничивать реализации. В enum должны быть константы, которые в будущем не изменятся и не пополнятся.
 * 3. Обращение к свойствам ограничивающим определенное множество объектов.
 *
 * Вывод:
 * 1. Если при подстановке нарушается поведение объекта, то это нарушение принципа Лисков.
 * 2. Если в коде присутствует адаптация под реализации, то скорее всего код нарушает принцип Лисков.
 * Это наблюдение исходит из первого, потому что под определенное поведение нам нужна определенная проверка.
 *
 * @author Alex_life
 * @version 1.0
 * @since 27.09.2022
 */
class AutoTransport {
    /* Рассмотрим 1. Предусловия.
    Допустим у нас есть класс AutoTransport и у него есть наследник - Bus.
    Предположим ему нужно больше топлива, чтобы сдвинуться с места */
    protected float fuel;

    public AutoTransport(float fuel) {
        this.fuel = fuel;
    }

    public void move(float km) {
        if (km < 0) {
            throw new IllegalArgumentException("Invalid distance!");
        }
        if (fuel < 0) { /* <= предусловие */
            throw new IllegalArgumentException("Need more fuel!");
        }
        /* other logic */
    }
}

/* От AutoTransport мы ожидаем, что машина сдвинется, но нет. Автобус не сдвигается, т.к. в нем усилено предусловие.
Ожидаем мы одно поведение, а получаем другое.
Чтобы сдвинуть автобус нам придется дописать доп. условие, чтобы проверить является ли транспорт автобусом.
Далее уже скормить ему больше топлива. */
class Bus extends AutoTransport {

    public Bus(float fuel) {
        super(fuel);
    }

    public void move(float km) {
        if (km < 0) {
            throw new IllegalArgumentException("Invalid distance!");
        }
        if (fuel < 5) { /* условие усилено */
            throw new IllegalArgumentException("Need more fuel!");
        }
        /* other logic */
    }
}

class FirstRule {
    public static void main(String[] args) {
        AutoTransport bus = new Bus(3);
        bus.move(2);
    }
}
