package ru.job4j.ood.srp;

import java.util.List;

/**
 * Принципы ООД (объектно-ориентированного дизайна)
 * Принцип единственной ответственности - Single Responsibility Principle
 *
 * Все шаблоны проектирования были придуманы как раз таким образом, чтобы код не только решал некоторую задачу дизайна,
 * но и соответствовал принципам SOLID. Таким образом,понимание этих принципов делает очевидными шаблоны проектирования.
 *
 * SOLID – это аббревиатура, составленная из первых букв названий принципов:
 * S – Single Responsibility Principle
 * O – Open-Closed Principle
 * L – Liskov Substitution Principle
 * I – Interface Segregation Principle
 * D – Dependency Inversion Principle
 *
 * Принцип SRP гласит: программная сущность (класс, пакет, модуль) должна иметь только одну ответственность.
 * В некоторых источниках можно встретить такую трактовку: класс должен иметь только одну причину для изменения.
 * Хотя, скорее второе это следствие из первого.
 *
 * Прежде чем начать детальное объяснение, нужно отметить две вещи:
 * 1) Принципы SOLID между собой связаны,
 * поэтому понимание отдельно взятого принципа зависит от комплексного понимания всех принципов
 * 2) Принципы SOLID базируются на основных принципах ООП. В некоторых источниках выделяют такой принцип как абстракция.
 * Без выделения абстракций невозможно воспринимать принципы SOLID.
 * Программными абстракциями являются интерфейсы и абстрактные классы. Если косвенно это соотнести с принципом SRP,
 * то интерфейсы и абстрактные классы должны отвечать за абстракцию, а реализации должны уже отвечать
 * за представление этих абстракций. Также это основа для соблюдения принципа OCP, о котором мы поговорим потом.
 *
 * Пример:
 * Написать класс, который генерирует последовательность случайных чисел и выводит ее.
 *
 * 1) Сперва мы выделяем абстракцию. В нашем случае это будет интерфейс SequenceGenerator
 *
 * 2) Далее пишем реализацию в классе SimpleSequenceGenerator
 *
 * 3) Смотрим на это и видим явное нарушение первого принципа:
 * -- реализации SequenceGenerator имеют различный функционал. Они умеют и генерировать последовательность,
 * -- и выводить куда-либо. А если нужно просто вывести? А если нужно просто сгенерировать?
 * -- Клиенту придется реализовывать этот функционал. Это результат некорректного выделения абстракции,
 * -- каждая абстракция должна отвечать только за представления своего функционала,
 * -- что тоже можно косвенно отнести к принципу SRP. В этом проявляется связь с принципом ISP.
 * 4) Для решения этой проблемы разделим интерфейсы по функциям на SequenceGeneratorSRP и Output.
 *
 * 5) Теперь реализация SimpleSequenceGeneratorSRP будет выполнять только предназначенную задачу, не зависимо от вывода.
 * Вывод будет зависеть от контекста.
 *
 * 6) Примечание: ранее было написано «имеют различный функционал», но не всегда очевидно, что функционал различный.
 * Если добавить метод List<T> generateInRange(T start, T end), можно ли сказать, что реализации генератора будут
 * иметь различный функционал? Нет. Все дело здесь в цели. Каждая абстракция должна преследовать только одну цель,
 * а ее методы это уже способы достижения поставленной цели.
 * Цель генератора последовательности – генерировать последовательность. Он может содержать и несколько методов,
 * но цель должна быть одна и та же. Стоит отметить, что это относится к открытому API классов,
 * т.е. вспомогательные приватные или protected методы к этому не относятся.
 *
 * 7) Если внимательно посмотреть на реализацию SimpleSequenceGeneratorSRP,
 * то снова можно увидеть нарушение SRP, потому что этот класс снова распыляется на разные задачи:
 * --Он знает как создать генератор случайных чисел.
 * --Как его настроить. В данном случае используется пустой конструктор, но классы же могут содержать и сложные
 * в построении классы, когда нужно знать, что именно передавать в конструкторы.
 * --Как генерировать, как бы это парадоксально ни звучало. Он знает, какой метод нужно вызвать.
 * Последний пункт можно проигнорировать, но при расширении программы вы будете замечать,
 * что логика самого генератора остается такой же – меняются лишь зависимости.
 *
 * В этом проявляется связь с принципом DIP – классы должны зависеть от абстракций, а нет от реализаций.
 * Также здесь есть зависимость с принципом OCP – по факту сам код генератора не расширяемый,
 * мы можем лишь создать новые реализации, а это расширение относится к контексту,
 * где будет применяться генератор последовательности, но не к самому генератору.
 *
 * 8) Чтобы решить эту проблему нужно выделить еще одну абстракцию – генератор чисел NumberGenerator
 * И сделать так чтобы генератор последовательности зависел от генерации числа. смотри SimpleSequenceGeneratorSRP2
 *
 * 9) Таким образом чтобы не нарушить Single Responsibility Principle, нужно:
 * 1. Обращать внимание на функционал, предоставляемый классом. У класса должна быть только одна цель.
 * 2. Обращать внимание на создаваемые объекты. Если класс умеет их создавать и инициализировать,
 * то это скорее всего нарушает принцип SRP.
 * 3. Обращать внимание на используемые операции, которые используются без зависимости.
 * Как в случае с генератором. Это могут быть неявные преобразования. Здесь антипаттерном служат статические библиотеки,
 * не предоставляющие стандарт языка.
 * Например, вы выводите дату в определенном формате, преобразование в формат есть преобразование, которое может
 * поменяться. В качестве примера можно также привести проверку условий, диктуемых из вне.
 * Например, поиск по файловой системе должен быть по предикату.
 *
 * @author Alex_life
 * @version 1.0
 * @since 24.09.2022
 */
public interface SequenceGenerator<T> {
    List<T> generate(int size);
    void print(List<T> numbers);
}
